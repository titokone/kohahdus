\subsection{Criterion}
public abstract class Criterion

{\bf Base class for all criterion types. The many different types of criteria in TitoTrainer
are all used via the interface defined here. The analyzer component does not know the
details of different Criterion sub-classes. Only the composer used for creating and
modiying Tasks is even aware that differnt types of criteria exist.}\\

{\tt 	public String getPositiveFeedback(TitoState studentAnswer)} \\
Return the positive feedback string of this Criterion. Criterion types that also
evaluate quality of the answer should overide this method so they can return a 
different string depending on the quality of the student's answer.\\

{\tt 	public String getNegativeFeedback()} \\
Return the negative feedback string of this Criterion \\

{\tt 	public boolean isSecretInputCriterion()} \\
 Return true if this criterion is to be used with secret input \\

{\tt 	public String serializeToXML()} \\
Return a serialized copy of this Criterion in XML-format \\
	
	
{\tt 	public abstract boolean meetsCriterion(TitoState studentAnswer, TitoState modelAnswer);} \\
Return true if student's answer meets the condition(s) of this criterion. Criterion
types that also evaluate quality of the answer must return <code>true</code> if the 
answer fullfills the passing requirement, even if answer was deemed low quality. \\

{\tt 	protected abstract String serializeSubClass();} \\
Serialize non-static data-members of Criterion sub-class to XML format. The subclass
can freely decide the names of the XML tags. The abstract Criterion class will handle
the serialization of its data-members. The serialized string is stored in the eAssari database in a 2000-char field so
subclasses should try to keep the tags and data short (without being cryptic). \\
	
{\tt 	protected abstract void initSubClass(String serializedXML);} \\
Initialize non-static data-members of this Criterion subclass instance using the 
serialized representation returned by <code>serializeToXML()</code>. The data-member
of the abstract Criterion class will have already been deserialized when this method
is called. \\
	
{\tt 	public static Criterion deserializeFromXML(String xml)} \\
Instantiate new Criterion object using the serialized form Xml \\
	
{\tt 	protected static String toXML(String tagname, boolean value)} \\
Serialize boolean value to XML string. Helper function for serializeSubClass() \\
	
{\tt 	protected static String toXML(String tagname, String value)} \\
Serialize String value to XML string. Helper function for serializeSubClass() \\
	
{\tt 	protected static String toXML(String tagname, int value)} \\
Serialize integer value to XML string. Helper function for serializeSubClass() \\

{\tt 	protected static boolean parseXMLBoolean(String XML, String tagname)} \\
Deserialize boolean value from XML string. Helper function for initSubClass() \\

{\tt 	protected static String parseXMLString(String XML, String tagname)} \\
Deserialize String value from XML string. Helper function for initSubClass() \\
	
{\tt 	protected static int parseXMLInt(String XML, String tagname)} \\
Deserialize integer value from XML string. Helper function for initSubClass() \\





\subsection{DBHandler}
public class DBHandler

{\bf Singleton class used for database interactions. Each public method of DBHandler class
encapsulates one database transaction, and thus may cause multiple inserts/updates/removes
with one call. The atomicity of the operations is quaranteed by using the transaction model
provided by the SQL standard.} \\
    
{\tt 		private DBHandler()} \\

{\tt 		public static synchronized DBHandler getInstance()} \\
Return DBHandler instance\\
	
{\tt 		private boolean init()} \\
	
{\tt 		protected void release(Connection conn) throws SQLException} \\

	// TODO: DBConnectionPool
	///      !!!!!!!!!!!!!!!!!! Tosi likainen ratkaisu ennen DBConnectionPool luokkaa
{\tt 		protected Connection getConnection () throws SQLException} \\

		
{\tt 		public Task[] getTasks()} \\
Return all tasks\\
	
{\tt 		public Task getTask(String taskID)} \\
Return task identified by taskID\\

{\tt		public Criterion[] getCriteria(Task task)}\\
Return the criteria of Task task\\
	
{\tt 		public void createTask(Task task, Criterion[] criteria)} \\
Add new task to task database. The insert will affect all courses. This operation
will also create the criteria for the task\\
	
{\tt 		public void updateTask(Task task, Criterion[] criteria)} \\
Update existing task. The update will affect all courses. This operation
will also update the criteria for the task.\\

{\tt 		public void removeTask(Task task)} \\
Remove task from task database (and thus all courses). This will also remove all stored
answers of the task.\\

{\tt 		public User[] getUsers(Course c) throws SQLException} \\
Return all users who have attempted to solve at least one task of Course c\\
	
{\tt 		public User getUser(String userID, String password) throws SQLException} \\
Return user identified by userID\\

{\tt 		public User getUser(String userID) throws SQLException} \\
Return user identified by userID\\

{\tt 		public void createUser(User user)} \\
Add new user to user database\\
	
{\tt 		public void updateUser(User user)} \\
Update existing user\\
	
{\tt 		private void addCriterion(Task t, Criterion c)} \\
Add criterion c to task\\
	
{\tt 		private void removeCriteria(Task t)} \\
Remove criteria form task\\
	
{\tt 		private void addTask(Course c, Task task)} \\
Add task to Course\\




\subsection{TitoState}
public class TitoState

{\bf Capsulates the end-state of single run of TitoKone.

This class will provide methods for querying the TitoKone end state.

Tämä luokka toteutetaan toisessa iteraatiossa}


